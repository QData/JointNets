#' function to evaluate results from jointnet (from simulated data)
#' @param result result generated using the same jointnet method
#' @param simulate result generated from function simulate
#' @export
evaluation <- function(result,simulate){
  comparisonplot(result,simulate$graphs)
  cat("BIC score is", BIC(simulate$samples,result))
  cat("\n")
  cat("F1 scores are", F1(simulate$graphs ,result))
}


#' function to return BIC score
#' @param datalist datalist used as an input to any of the jointnet method
#' @param result result generated from datalist using the same jointnet method
#' @return BIC score (lower scores correspond to better estimation)
BIC <- function(datalist, result){
  K = length(datalist)
  covs = list()
  n = 0
  for (i in 1:K){
  covs[[i]] = cov(datalist[[i]])
  n = n + dim(datalist[[i]])[1]
  }
  graphs = result$graphs
  p = dim(datalist[[i]])[2]
  return(BIC_matrix(covs,graphs,n,p))
}

#' function to calculate BIC score of a list of estimated precision matrices
#' @param covs   -- a list of empirical covariance matrices
#' @param graphs -- a list of estimated precision matrices
#' @param n      -- total number of samples (total number of samples from all lists)
#' @param p      -- number of features
#' @return BIC score
BIC_matrix <- function(covs, graphs, n, p){
  N = length(covs)
  bic = 0
  #calculate loglikelihood
  for(i in 1:N){
    bic = determinant(graphs[[i]])$modulus[1] - sum(diag(covs[[i]] %*% graphs[[i]])) + bic
  }
  #calculate bic
  bic = -2 * bic + ((p * p - p) / 2 + p) * log(n)
  return(bic)
}

#' function to calculate F1 score
#' @param simulate result from simulateGraph
#' @param result result from any of the jointnets method using the samples generated by simulate
#' @return a list of F1 scores between simulate and result between 0 and 1 (higher scores correspond to better estimation)
#' @details scores' order correspond to task order and the last score in the list represent score for shared graph (only applicable to simule and wsimule)
F1 <- function(simulate, result) {
  K = length(simulate$graphs)
  hasshare = !is.null(result$share)
  simulate = make_adj_matrix(simulate,TRUE)
  result = make_adj_matrix(result,TRUE)
  f1 = c()
  for (i in 1:K) {
    f1[i] = F1_single(simulate[[i]],result[[i]])
  }

  if (hasshare){
    f1[K+1] = F1_single(simulate$share,result$share)
  }

  ### need to revise on this to adapt to diffee
  return(f1)
}

#' function to calculate F1 score for a single simulate graph with a single result graph
#' @param simulate single precision matrix of simulateGraph
#' @param result single corresponding precision matrix generated by any of the jointnets method
#' @return a single F1 score between simulate and result between 0 and 1 (higher scores correspond to better estimation)
F1_single <- function(simulate,result){
  tP = sum((result == 1) & (simulate == 1))
  tN = sum((result == 0) & (simulate == 0))
  fP = sum((result == 1) & (simulate == 0))
  fN = sum((result == 0) & (simulate == 1))
  pPM = tP / (tP + fP)
  rPM = tP / (tP + fN)
  return(2 * pPM * rPM / (pPM + rPM))
}
